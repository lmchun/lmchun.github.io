<!DOCTYPE html>
<html lang="en">
	<head>
		<title>environment 2</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link type="text/css" rel="stylesheet" href="main.css">
		<!-- WebXR Device API (For Chrome M76+), expires 10/16/2019 -->
		<meta http-equiv="origin-trial" content="AtWCPo0cZgy0zJDSYftemy7eZvmcwR5qy/4osFkMkLZ0ar6OYyKfbu93pjpxiOVzcWNIVxgoWoK8YtxCXeFSqgIAAABTeyJvcmlnaW4iOiJodHRwczovL3RocmVlanMub3JnOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkRldmljZU03NiIsImV4cGlyeSI6MTU3MTE4Mzk5OX0=">
	</head>
	<body>

		<script src="js/vr/HelioWebXRPolyfill.js"></script>
		<script src="../build/three.min.js"></script>

		<script type="module">
			import * as THREE from '../build/three.module.js';
			import { Lensflare, LensflareElement } from './jsm/objects/Lensflare.js';
			import { Reflector } from './jsm/objects/Reflector.js';
			import { WEBVR } from './jsm/vr/WebVR.js';
			var camera, scene, renderer;
			var reflector;
			init();
			animate();
			function init() {
				var background = new THREE.CubeTextureLoader()
					.setPath( 'textures/cube/nightsky/' )
					.load( [ 'left.jpg', 'right.jpg', 'top.jpg', 'bot.jpg', 'back.jpg', 'front.jpg' ] );
				background.format = THREE.RGBFormat;
				scene = new THREE.Scene();
				scene.background = background;
				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.1, 10 );
				
				//torus part of the code
				// var geometry = new THREE.TorusKnotBufferGeometry( 0.4, 0.15, 150, 20 );
				// var material = new THREE.MeshStandardMaterial( { roughness: 0.01, metalness: 0.2, envMap: background } );
				// var mesh = new THREE.Mesh( geometry, material );
				// mesh.position.y = 0.75;
				// mesh.position.z = - 2;
				// mesh.castShadow = true;
				// mesh.receiveShadow = true;
				// scene.add( mesh );
				// var geometry = new THREE.BoxBufferGeometry( 1.5, 0.1, 1.5 );
				// var material = new THREE.MeshPhongMaterial();
				// var mesh = new THREE.Mesh( geometry, material );
				// mesh.position.y = - 0.2;
				// mesh.position.z = - 2;
				// mesh.castShadow = true;
				// mesh.receiveShadow = true;
				// scene.add( mesh );
				//end of the torus code

				//particles
				// create the particle variables
				var particleCount = 1800,
				    particles = new THREE.Geometry(),
				    pMaterial = new THREE.ParticleBasicMaterial({
				      color: 0xFFFFFF,
				      size: 20
				    });

				// now create the individual particles
				for (var p = 0; p < particleCount; p++) {

				  // create a particle with random
				  // position values, -250 -> 250
				  var pX = Math.random() * 500 - 250,
				      pY = Math.random() * 500 - 250,
				      pZ = Math.random() * 500 - 250,
				      particle = new THREE.Vertex(
				        new THREE.Vector3(pX, pY, pZ)
				      );

				  // add it to the geometry
				  particles.vertices.push(particle);
				}

				// create the particle system
				var particleSystem = new THREE.ParticleSystem(
				    particles,
				    pMaterial);

				// add it to the scene
				scene.add(particleSystem);

				//custom geometry//
				var geometry, material, mesh;
				geometry = new THREE.TorusKnotGeometry(115.31, 41.98, 100, 100, 15, 3, 1);
				material = new THREE.MeshPhongMaterial({shading: THREE.FlatShading, color: 0xa6b8f2, ambient: 0xf7a5a5, emissive: 0x000000, specular: 0x5db6f5, shininess: -3.23, transparent: true, opacity: 0.72});
				mesh = new THREE.Mesh(geometry, material);
				scene.add(mesh);

				var light = new THREE.DirectionalLight( 0x8800ff );
				light.position.set( - 1, 1.5, - 1.5 );
				light.castShadow = true;
				light.shadow.camera.zoom = 4;
				scene.add( light );
				light.target.position.set( 0, 0, - 2 );
				scene.add( light.target );
				// var helper = new CameraHelper( light.shadow.camera );
				// scene.add( helper );
				var light = new THREE.DirectionalLight( 0xff0000 );
				light.position.set( 1, 1.5, - 2.5 );
				light.castShadow = true;
				light.shadow.camera.zoom = 4;
				scene.add( light );
				light.target.position.set( 0, 0, - 2 );
				scene.add( light.target );
				// var helper = new CameraHelper( light.shadow.camera );
				// scene.add( helper );
				// lensflare
				var loader = new THREE.TextureLoader();
				var texture0 = loader.load( "textures/lensflare/lensflare0.png" );
				var texture3 = loader.load( "textures/lensflare/lensflare3.png" );
				var lensflare = new Lensflare();
				lensflare.position.set( 0, 5, - 5 );
				lensflare.addElement( new LensflareElement( texture0, 700, 0 ) );
				lensflare.addElement( new LensflareElement( texture3, 60, 0.6 ) );
				lensflare.addElement( new LensflareElement( texture3, 70, 0.7 ) );
				lensflare.addElement( new LensflareElement( texture3, 120, 0.9 ) );
				lensflare.addElement( new LensflareElement( texture3, 70, 1 ) );
				scene.add( lensflare );

			

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.autoClear = false;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				renderer.vr.enabled = true;
				document.body.appendChild( renderer.domElement );
				document.body.appendChild( WEBVR.createButton( renderer ) );
				

				//
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				renderer.setAnimationLoop( render );
			}
			function render() {
				var time = performance.now() * 0.0002;
				// var mesh = scene.children[ 0 ];
				// mesh.rotation.x = time * 2;
				// mesh.rotation.y = time * 5;
				renderer.render( scene, camera );
			}
		</script>
	</body>
</html>